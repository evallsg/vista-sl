<html>
    <head>
        <title>VISTA-SL Demo</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="icon" type="image/x-icon" href="https://avatars.slack-edge.com/2025-04-17/8790996987232_b71f912cab2b8dbb26e6_88.jpg">
        <link rel="stylesheet" href="https://cdn.skypack.dev/lexgui@0.6.9/build/lexgui.css">
        <style>
            html, body { width:100%; height:100%; margin:0; padding:0; overflow:hidden; }
        </style>
        <script src="./external/jquery-3.6.0.min.js"></script>
        <script async src="./external/es-module-shims.js"></script>

        <script type="importmap">
			{
				"imports": {
					"three": "./external/three/build/three.module.js",
                    "three/addons/": "./external/three/jsm/",
                    "lexgui": "https://cdn.skypack.dev/lexgui@0.6.9/build/lexgui.module.js",
                    "lexgui/components/": "https://cdn.skypack.dev/lexgui@0.6.9/build/components/"
                }
            }
		</script>
    </head>
    <body>
        <div id="loading" class="modal" style="background-color:rgba(51, 51, 51, 0.5); position: absolute; width: 100%; height: 100%; 
                display: flex; justify-content: center; align-items: center; z-index: 100; color: white; font-size: larger;">
			<p>Loading avatar, please wait</p>
		</div>
        <!-- <div style="display: flex; flex-direction: row;">

            <div style="width: 50%;">
                <video src="crawl-catsl/videos/video-Î©.mp4"></video>
            </div>
            <div style="width: 50%;" id="scene"></div>
        </div> -->

            <script type="module">
                import { Performs } from './js/Performs.js'
                import { LX } from 'lexgui'
                import 'lexgui/components/videoeditor.js';
                import * as THREE from 'three'
                import { DrawingUtils, HandLandmarker, FilesetResolver} from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.13';
                
                let runningMode = "IMAGE";
                let handLandmarker = null;

                const performs = new Performs();
                performs.init({srcReferencePose: 2, trgReferencePose: 2, restrictView: false});
                performs.changeMode(Performs.Modes.KEYFRAME);
                window.global = {app: performs};
                const delayedResizeTime = 500; //ms
                let delayedResizeID = null;
                const leftLandmakrs3D = new THREE.Group();
                const rightLandmakrs3D = new THREE.Group();
                for(let i = 0; i < 21; i++) {
                    const geometry = new THREE.SphereGeometry( 1, 10, 10 ); 
                    const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } ); 
                    const sphere = new THREE.Mesh( geometry, material ); 
                    sphere.scale.set(0.01, 0.01, 0.01);
                    leftLandmakrs3D.add( sphere );
                    rightLandmakrs3D.add( sphere.clone() );
                }

                const avatars = {
                    "EvaLow": [Performs.AVATARS_URL+'Eva_Low/Eva_Low.glb', Performs.AVATARS_URL+'Eva_Low/Eva_Low.json', 0, Performs.AVATARS_URL+'Eva_Low/Eva_Low.png'],
                    "Witch": [Performs.AVATARS_URL+'Eva_Witch/Eva_Witch.glb', Performs.AVATARS_URL+'Eva_Witch/Eva_Witch.json', 0, Performs.AVATARS_URL+'Eva_Witch/Eva_Witch.png'],
                    "Kevin": [Performs.AVATARS_URL+'Kevin/Kevin.glb', Performs.AVATARS_URL+'Kevin/Kevin.json', 0, Performs.AVATARS_URL+'Kevin/Kevin.png'],
                    "Ada": [Performs.AVATARS_URL+'Ada/Ada.glb', Performs.AVATARS_URL+'Ada/Ada.json',0, Performs.AVATARS_URL+'Ada/Ada.png'],
                    "Eva": ['https://models.readyplayer.me/66e30a18eca8fb70dcadde68.glb', Performs.AVATARS_URL+'ReadyEva/ReadyEva_v3.json',0, 'https://models.readyplayer.me/66e30a18eca8fb70dcadde68.png?background=68,68,68'],
                    "Victor": ['https://models.readyplayer.me/66e2fb40222bef18d117faa7.glb', Performs.AVATARS_URL+'ReadyVictor/ReadyVictor.json',0, 'https://models.readyplayer.me/66e2fb40222bef18d117faa7.png?background=68,68,68']
                }
                
                let drawingUtils = null;
                let drawingUtilsCharacter = null;
                const init = async () => {
                    performs.scene.add(leftLandmakrs3D);
                    performs.scene.add(rightLandmakrs3D);
                    
                    const response = await fetch( "animations.json" );
                    let animationsMap = null;
                    if( response.ok ) {
                        animationsMap = await response.json();
                    }
                    const mainArea = await LX.init({});
                    const [menubar, containerArea] = mainArea.split({type: "vertical", sizes: ["200px", "auto"]});
                    const [leftArea, rightArea] = containerArea.split({sizes: ["50%", "auto"]});
                    const container = LX.makeContainer(["auto", "auto"], "", `<video id="video" class="hidden" controls style="width:100%;position:absolute;"></video><canvas id="reference-mediapipe-canvas" class="hidden" style="width:100%;position:absolute;"></canvas><div id="select-video">Select a video</div>`, leftArea);
                    container.style.position = "relative";
                    
                    // const canvasArea = LX.makeContainer(["auto", "auto"], "", ``, rightArea);
                    // canvasArea.style="width:100%;position:absolute;";
                    
                    const characterCanvas = document.createElement('canvas');
                    characterCanvas.id="character-mediapipe-canvas";
                    characterCanvas.style="width:100%;position:absolute;";
                    characterCanvas.className="hidden";
                    
                    characterCanvas.style.pointerEvents = "none";
                    rightArea.root.id = "scene";
                    rightArea.attach(characterCanvas);
                    rightArea.root.style.position = "relative";
                    
                    rightArea.onresize = (bounding) => delayedResize(bounding.width, bounding.height);
                    displayCanvas();
                    initMediapipe();                    
                    const video = document.getElementById( "video" );
                    const canvas = document.getElementById( "reference-mediapipe-canvas" );
                    canvas.style.pointerEvents = "none";
                    drawingUtils = new DrawingUtils( canvas.getContext("2d") ); 
                    drawingUtilsCharacter = new DrawingUtils( characterCanvas.getContext("2d") ); 
                    
                    const buttonsPanel = menubar.addPanel( {className: "m-6", width: "20%"});
                            
                    buttonsPanel.addTitle("Select a video", {style: { background: "none"}});

                    const values = Object.keys(animationsMap);
                    buttonsPanel.addSelect("SL Video", values, null, async (signName, event) => {
                        const response = await fetch( animationsMap[signName] );
                        if( response.ok ) {
                            const data = await response.text();
                            performs.keyframeApp.loadFiles( [ {name: animationsMap[signName], data}] , ( animationName ) => {
                                canvas.classList.remove("hidden");
                                characterCanvas.classList.remove("hidden");
                                video.classList.remove("hidden");
                                video.src = `https://catsl.eelvex.net/static/vid/teacher-${signName}.mp4`;
                                const landmarksDataUrl = 'https://catsl.eelvex.net/static/vid_data/teacher-' + signName + '/teacher-' + signName + '_keyframe_1.json';
                                const el = document.getElementById("select-video").classList.add("hidden");
                                // videoEditor._loadVideo()
                                video.onloadeddata = async (e) => { 
                                    //video.play();
                                    // video.fastSeek(0.0);
                                    canvas.width = video.videoWidth;
                                    canvas.height = video.videoHeight;
                                    video.currentTime = 0.0;
                                    performs.keyframeApp.onChangeAnimation(animationName, true);
                                    performs.keyframeApp.changePlayState(false);
                                    const animation = performs.keyframeApp.bindedAnimations[animationName][performs.currentCharacter.model.name];
                                    const mixer = performs.currentCharacter.mixer;
                                    const response = await fetch( landmarksDataUrl );
                                    if( response.ok ) {
                                        const landmarksData = await response.json();
                                        const landmarks = landmarksData[0].landmarks;
                                        if(landmarks) {
                                            landmarks.map(landmark => {
                                                return {
                                                    x: 1 - landmark.x,
                                                    y: landmark.y,
                                                    visibility: landmark.visibility
                                                };
                                            });
                                            drawingUtils.drawConnectors( landmarks, HandLandmarker.HAND_CONNECTIONS, {color: '#1a2025', lineWidth: 4}); //'#00FF00'
                                            drawingUtils.drawLandmarks( landmarks, {color: '#1a2025',fillColor: 'rgba(255, 255, 255, 1)', lineWidth: 2}); //'#00FF00'
                                        
                                            // const imgData = performs.renderer.domElement.toDataURL('image/png');
                                            // const img = document.createElement('img');
                                            // img.src = imgData;
                                                // const originalImage = await createImageBitmap(performs.renderer.domElement);
                                                  
                                            requestAnimationFrame(animate);
                                            // performs.renderer.render(performs.scene, performs.cameras[performs.camera]);
                                            const imgData = performs.renderer.domElement.toBlob( ( blob ) => { 
                                                const imgEl = document.createElement( 'img' );
                                                imgEl.src = URL.createObjectURL( blob );
                                                document.body.appendChild(imgEl);
                                                
                                                // var dataURL = performs.renderer.domElement.toDataURL('image/png');
                                                // var imgSrc = dataURL.replace(/^data:image\/[^;]/, 'data:application/octet-stream');
                                                // console.log({dataURL});
                                                // imgEl.src = imgSrc;
                                                // imgEl.onload = () => {

                                                //         const detectionsHand = handLandmarker.detect(imgEl);
                                                //         const ctx = canvas.getContext('2d');
                                                //         ctx.save();
                                                //         ctx.clearRect(0, 0, canvas.width, canvas.height);
                                                //         canvas.drawImage(canvas, 0, 0, canvas.width, canvas.height);
                                                //         if (detectionsHand.landmarks) {
                                                //             for (const detectedLandmarks of detectionsHand.landmarks) {
                                                //                 let score = score_and_drawTeacherLandmarks();
                                                //                 let color = scoreToColor(score);
        
                                                //                 if (prevLandmarks) {
                                                //                 for (let i = 0; i < detectedLandmarks.length; i++) {
                                                //                     detectedLandmarks[i].x = smoothingFactor * detectedLandmarks[i].x + (1 - smoothingFactor) * prevLandmarks[i].x;
                                                //                     detectedLandmarks[i].y = smoothingFactor * detectedLandmarks[i].y + (1 - smoothingFactor) * prevLandmarks[i].y;
                                                //                 }
                                                //                 }
                                                //                 prevLandmarks = detectedLandmarks
        
                                                //                 drawingUtils.drawConnectors(detectedLandmarks, handLandmarker.HAND_CONNECTIONS, { color: "#f0f0f0", lineWidth: 2 });
                                                //                 drawingUtils.drawLandmarks(detectedLandmarks, { color: color, lineWidth: 2 });
                                                //             }
                                                //         }
                                                //     }
                                                // originalImage.close();
                                            });
                                            
                                        }
                                    }
                                    // for(let action of mixer._actions) {
                                    //     action.setLoop(THREE.LoopOnce, 1);
                                    //     action.clampWhenFinished = true;                                            
                                    // }
                                }
                                
                                video.onplay = (e) => {
                                    const mixer = performs.currentCharacter.mixer;
                                    performs.keyframeApp.changePlayState(!video.paused);
                                    mixer.setTime(video.currentTime);
                                }

                                video.onpause = (e) => {
                                    const mixer = performs.currentCharacter.mixer;
                                    performs.keyframeApp.changePlayState(!video.paused);
                                    mixer.setTime(video.currentTime);
                                }
                                video.ontimeupdate = (e) => {
                                    const mixer = performs.currentCharacter.mixer;
                                    if( video.paused ) {
                                        mixer.setTime(video.currentTime);
                                    }
                                }

                                video.onended = (e) => {
                                    performs.keyframeApp.changePlayState(false);
                                    const mixer = performs.currentCharacter.mixer;
                                    mixer.setTime(0);
                                }

                            })
                        }
                    }, { filter: true, overflowContainerY: containerArea.root});           
                    
                    const avatarsInfo = [];

                    for(let avatar in avatars) {
                        avatarsInfo.push( { value: avatar, src: avatars[avatar][3]} );
                    }
                    buttonsPanel.addSelect("Characters", avatarsInfo, avatarsInfo[0].value, async (value, event) => {
                        $('#loading').fadeIn();
                        performs.loadAvatar(avatars[value][0], avatars[value][1] , new THREE.Quaternion(), value, () => {
                            performs.changeAvatar( value );
                            const mixer = performs.currentCharacter.mixer;
                            mixer.setTime(video.currentTime)
                            //innerAvatarSettings(settings);
            
                            $('#loading').fadeOut(); //hide();               
                        }, (err) => {
                            $('#loading').fadeOut();
                            alert("There was an error loading the avatar", "Avatar not loaded");
                        } );
                    }, { filter: true, overflowContainerY: containerArea.root })
                }
                let prevLandmarks = null;
                const animate = async () => {
                    const bitmap = await createImageBitmap(performs.renderer.domElement);
                
                    const characterCanvas = document.getElementById("character-mediapipe-canvas");
                    const canvasCtx = characterCanvas.getContext('2d'); 
                    canvasCtx.clearRect(0, 0, characterCanvas.width, characterCanvas.height);
                    
                    const detectionsHand = handLandmarker.detect(bitmap);
                    bitmap.close();
     
                    leftLandmakrs3D.visible = false;
                    rightLandmakrs3D.visible = false;
                    
                    if (detectionsHand.landmarks.length) {
                        for (const detectedLandmarks of detectionsHand.landmarks) {
                            // let score = score_and_drawTeacherLandmarks();
                            let color = 'red'//scoreToColor(score);
                            let smoothingFactor = 1;
                            if (prevLandmarks) {
                            for (let i = 0; i < detectedLandmarks.length; i++) {
                                detectedLandmarks[i].x = smoothingFactor * detectedLandmarks[i].x + (1 - smoothingFactor) * prevLandmarks[i].x;
                                detectedLandmarks[i].y = smoothingFactor * detectedLandmarks[i].y + (1 - smoothingFactor) * prevLandmarks[i].y;
                            }
                            }
                            prevLandmarks = detectedLandmarks;
                            drawingUtilsCharacter.drawConnectors(detectedLandmarks, handLandmarker.HAND_CONNECTIONS, { color: "#f0f0f0", lineWidth: 2 });
                            drawingUtilsCharacter.drawLandmarks(detectedLandmarks, { color: color, lineWidth: 2 });                            
                        }
                        for (let j = 0; j < detectionsHand.worldLandmarks.length; j++ ) {
                            const hand = detectionsHand.handedness[j][0].categoryName;
                            const hand3D = performs.scene.getObjectByName(`mixamorig_${hand}Hand`);
                            // let pos = new THREE.Vector3(0.5, 1, 0);
                            let pos = new THREE.Vector3();
                            let q = new THREE.Quaternion();
                            if(hand3D) {
                                hand3D.getWorldPosition(pos);
                                hand3D.getWorldQuaternion(q);
                            }
                            const detectedLandmarks = detectionsHand.worldLandmarks[j];
                            // const pm = [new THREE.Vector3(), new THREE.Vector3()];
                            // for (let i = 0; i < detectedLandmarks.length; i++) {
                            //     pm[j].x += detectedLandmarks[i].x;
                            //     pm[j].y += detectedLandmarks[i].y;
                            //     pm[j].z += detectedLandmarks[i].z;
                            // }

                            // pm[j].x /= 21;
                            // pm[j].y /= 21;
                            // pm[j].z /= 21;
                            
                            if(hand == "Right") {
                                rightLandmakrs3D.position.copy(pos);
                            }
                            else {
                                leftLandmakrs3D.position.copy(pos);
                            }
                            for (let i = 0; i < detectedLandmarks.length; i++) {
                                if(hand == "Left") {
                                    leftLandmakrs3D.visible = true;
                                    leftLandmakrs3D.children[i].position.x = detectedLandmarks[i].x - detectedLandmarks[0].x;
                                    leftLandmakrs3D.children[i].position.y = detectedLandmarks[i].y - detectedLandmarks[0].y;
                                    leftLandmakrs3D.children[i].position.z = detectedLandmarks[i].z - detectedLandmarks[0].z;
                                    // leftLandmakrs3D.children[i].rotateOnAxis(new THREE.Vector3(0,1,0), Math.PI*0.5);
                                    // leftLandmakrs3D.children[i].quaternion.copy(q);
                                }
                                else {
                                    rightLandmakrs3D.visible = true;
                                    rightLandmakrs3D.children[i].position.x = detectedLandmarks[i].x - detectedLandmarks[0].x;
                                    rightLandmakrs3D.children[i].position.y = detectedLandmarks[i].y - detectedLandmarks[0].y;
                                    rightLandmakrs3D.children[i].position.z = detectedLandmarks[i].z - detectedLandmarks[0].z;
                                    // rightLandmakrs3D.children[i].rotateOnAxis(new THREE.Vector3(0,1,0), Math.PI*0.5);
                                    // rightLandmakrs3D.children[i].quaternion.copy(q);
                                }
                            }
                        }                        
                    }
                    requestAnimationFrame(animate);
                }

                const displayCanvas = () => {
                    if(!performs.isAppReady) {
                        setTimeout(displayCanvas, 1000);
                        return;
                    }
                    const div = document.getElementById("scene");
                    div.appendChild(performs.renderer.domElement);
                    delayedResize(div.clientWidth, div.clientHeight);
                    // const canvasNode = document.getElementsByClassName("canvas")[0];
                    // document.body.removeChild(canvasNode);
                }

                // Waits until delayedResizeTime to actually resize webGL. New calls reset timeout. To avoid slow resizing and crashes.
                const delayedResize = ( width, height ) => {
                    if ( delayedResizeID ) {
                        clearTimeout(delayedResizeID); delayedResizeID = null;
                    }
                    delayedResizeID = setTimeout( () => { delayedResizeID = null; resize(width, height); }, delayedResizeTime );

                    resize(width, height);
                }

                const resize = ( width, height ) => {
                    for (let i = 0; i < performs.cameras.length; i++) {
                        performs.cameras[i].aspect = width / height;
                        performs.cameras[i].updateProjectionMatrix();
                    }
                    performs.renderer.setSize( width, height );
                    const characterCanvas = document.getElementById("character-mediapipe-canvas");
                    characterCanvas.width = width;
                    characterCanvas.height = height;
                    const canvasCtx = characterCanvas.getContext('2d');
                    canvasCtx.clearRect(0, 0, characterCanvas.width, characterCanvas.height);
                }

                const initMediapipe = async() => {
                    const vision = await FilesetResolver.forVisionTasks(
                        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
                        );
                        handLandmarker = await HandLandmarker.createFromOptions(vision, {
                        baseOptions: {
                            modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                            delegate: "GPU"
                        },
                        runningMode: runningMode,
                        numHands: 2
                    });
                }
                const transformLandmarks = (originalLandmarks, newLandmarks) => {
                    // Assume originalLandmarks and newLandmarks are arrays of landmarks
                    // and originalLandmarks[0] and newLandmarks[0] are the wrists
                    originalLandmarks = flipLandmarks(originalLandmarks);

                    // Scale
                    let axis0 = 0;
                    let axis1 = 5;
                    let scale = Math.sqrt(Math.pow(newLandmarks[axis0].x - newLandmarks[axis1].x, 2) + Math.pow(newLandmarks[axis0].y - newLandmarks[axis1].y, 2)) /
                    Math.sqrt(Math.pow(originalLandmarks[axis0].x - originalLandmarks[axis1].x, 2) + Math.pow(originalLandmarks[axis0].y - originalLandmarks[axis1].y, 2));
                    axis0 = 5;
                    axis1 = 17;
                    let scale2 = Math.sqrt(Math.pow(newLandmarks[axis0].x - newLandmarks[axis1].x, 2) + Math.pow(newLandmarks[axis0].y - newLandmarks[axis1].y, 2)) /
                        Math.sqrt(Math.pow(originalLandmarks[axis0].x - originalLandmarks[axis1].x, 2) + Math.pow(originalLandmarks[axis0].y - originalLandmarks[axis1].y, 2));
                    if (scale2 > scale) {
                    scale = scale2;
                    }

                    // Apply scaling
                    let scaledLandmarks = originalLandmarks.map(landmark => {
                    let dx = landmark.x - originalLandmarks[0].x;
                    let dy = landmark.y - originalLandmarks[0].y;
                    return {
                        x: originalLandmarks[0].x + dx * scale,
                        y: originalLandmarks[0].y + dy * scale,
                        visibility: landmark.visibility
                    };
                    });

                    // Compute rotation angle for each joint and apply rotation
                    let rotatedLandmarks = scaledLandmarks.map((landmark, index) => {
                    let dx = landmark.x - scaledLandmarks[0].x;
                    let dy = landmark.y - scaledLandmarks[0].y;
                    let distance = Math.sqrt(dx*dx + dy*dy);

                    // Compute rotation angle for this joint
                    let angleOriginal = Math.atan2(originalLandmarks[index].y - originalLandmarks[0].y, originalLandmarks[index].x - originalLandmarks[0].x);
                    let angleNew = Math.atan2(newLandmarks[index].y - newLandmarks[0].y, newLandmarks[index].x - newLandmarks[0].x);
                    let dAngle = angleNew - angleOriginal;

                    // If dAngle is within the maximum rotation angle, use it, otherwise use the maximum rotation angle
                    let maxTheta = Math.PI * 0.025;
                    let rotationAngle = Math.abs(dAngle) <= maxTheta ? dAngle : Math.sign(dAngle) * maxTheta;

                    // Apply rotation to this joint
                    return {
                        x: scaledLandmarks[0].x + distance * Math.cos(angleOriginal + rotationAngle),
                        y: scaledLandmarks[0].y + distance * Math.sin(angleOriginal + rotationAngle),
                        visibility: landmark.visibility
                    };
                    });


                    // Create an array to hold the adjusted landmarks
                    let adjustedLandmarks = [];

                    // Process each landmark in order
                    for (let index = 0; index < rotatedLandmarks.length; index++) {
                    let landmark = rotatedLandmarks[index];

                    if (index === 0 || index === 1 || index === 5 || index === 9 || index === 13 || index === 17) {
                        // No need to adjust for the wrist or the bases of the fingers
                        adjustedLandmarks.push(landmark);
                    } else {
                        // Only adjust for the tips of the fingers
                        // if ([3,4,7,8,11,12,15,16,19,20].includes(index)) {
                        // Calculate the original distance from the current joint to the tip
                        let rotatedDistance = Math.sqrt(Math.pow(landmark.x - rotatedLandmarks[index - 1].x, 2) + Math.pow(landmark.y - rotatedLandmarks[index - 1].y, 2));

                        // Calculate the direction from the joint to the tip
                        let dx = landmark.x - rotatedLandmarks[index - 1].x;
                        let dy = landmark.y - rotatedLandmarks[index - 1].y;

                        // Normalize the direction
                        let length = Math.sqrt(dx * dx + dy * dy);
                        dx /= length;
                        dy /= length;

                        // Scale the direction by the original distance
                        let desiredDistance = Math.min(rotatedDistance, 3.1 * length);
                        dx *= desiredDistance;
                        dy *= desiredDistance;

                        // Add the scaled direction to the joint's position to get the new position for the tip
                        adjustedLandmarks.push({
                            x: rotatedLandmarks[index - 1].x + dx,
                            y: rotatedLandmarks[index - 1].y + dy,
                            visibility: landmark.visibility
                        });
                        // } else {
                        // adjustedLandmarks.push(landmark);
                        // }
                    }
                    }
                    // Apply translation
                    let transformedLandmarks = adjustedLandmarks.map(landmark => {
                    return {
                        x: landmark.x + newLandmarks[0].x - adjustedLandmarks[0].x,
                        y: landmark.y + newLandmarks[0].y - adjustedLandmarks[0].y,
                        visibility: landmark.visibility
                    };
                    });


                    return transformedLandmarks;
                }

                init();
            </script>

    </body>
</html>